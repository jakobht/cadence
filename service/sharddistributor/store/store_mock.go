// Code generated by MockGen. DO NOT EDIT.
// Source: store.go
//
// Generated by this command:
//
//	mockgen -package store -source store.go -destination=store_mock.go Store
//

// Package store is a generated GoMock package.
package store

import (
	context "context"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockTxn is a mock of Txn interface.
type MockTxn struct {
	ctrl     *gomock.Controller
	recorder *MockTxnMockRecorder
	isgomock struct{}
}

// MockTxnMockRecorder is the mock recorder for MockTxn.
type MockTxnMockRecorder struct {
	mock *MockTxn
}

// NewMockTxn creates a new mock instance.
func NewMockTxn(ctrl *gomock.Controller) *MockTxn {
	mock := &MockTxn{ctrl: ctrl}
	mock.recorder = &MockTxnMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTxn) EXPECT() *MockTxnMockRecorder {
	return m.recorder
}

// MockStore is a mock of Store interface.
type MockStore struct {
	ctrl     *gomock.Controller
	recorder *MockStoreMockRecorder
	isgomock struct{}
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder struct {
	mock *MockStore
}

// NewMockStore creates a new mock instance.
func NewMockStore(ctrl *gomock.Controller) *MockStore {
	mock := &MockStore{ctrl: ctrl}
	mock.recorder = &MockStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore) EXPECT() *MockStoreMockRecorder {
	return m.recorder
}

// AssignShard mocks base method.
func (m *MockStore) AssignShard(ctx context.Context, namespace, shardID, executorID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AssignShard", ctx, namespace, shardID, executorID)
	ret0, _ := ret[0].(error)
	return ret0
}

// AssignShard indicates an expected call of AssignShard.
func (mr *MockStoreMockRecorder) AssignShard(ctx, namespace, shardID, executorID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AssignShard", reflect.TypeOf((*MockStore)(nil).AssignShard), ctx, namespace, shardID, executorID)
}

// AssignShards mocks base method.
func (m *MockStore) AssignShards(ctx context.Context, namespace string, request AssignShardsRequest, guard GuardFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AssignShards", ctx, namespace, request, guard)
	ret0, _ := ret[0].(error)
	return ret0
}

// AssignShards indicates an expected call of AssignShards.
func (mr *MockStoreMockRecorder) AssignShards(ctx, namespace, request, guard any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AssignShards", reflect.TypeOf((*MockStore)(nil).AssignShards), ctx, namespace, request, guard)
}

// DeleteExecutors mocks base method.
func (m *MockStore) DeleteExecutors(ctx context.Context, namespace string, executorIDs []string, guard GuardFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteExecutors", ctx, namespace, executorIDs, guard)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteExecutors indicates an expected call of DeleteExecutors.
func (mr *MockStoreMockRecorder) DeleteExecutors(ctx, namespace, executorIDs, guard any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteExecutors", reflect.TypeOf((*MockStore)(nil).DeleteExecutors), ctx, namespace, executorIDs, guard)
}

// GetHeartbeat mocks base method.
func (m *MockStore) GetHeartbeat(ctx context.Context, namespace, executorID string) (*HeartbeatState, *AssignedState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetHeartbeat", ctx, namespace, executorID)
	ret0, _ := ret[0].(*HeartbeatState)
	ret1, _ := ret[1].(*AssignedState)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetHeartbeat indicates an expected call of GetHeartbeat.
func (mr *MockStoreMockRecorder) GetHeartbeat(ctx, namespace, executorID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetHeartbeat", reflect.TypeOf((*MockStore)(nil).GetHeartbeat), ctx, namespace, executorID)
}

// GetShardOwner mocks base method.
func (m *MockStore) GetShardOwner(ctx context.Context, namespace, shardID string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetShardOwner", ctx, namespace, shardID)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetShardOwner indicates an expected call of GetShardOwner.
func (mr *MockStoreMockRecorder) GetShardOwner(ctx, namespace, shardID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetShardOwner", reflect.TypeOf((*MockStore)(nil).GetShardOwner), ctx, namespace, shardID)
}

// GetState mocks base method.
func (m *MockStore) GetState(ctx context.Context, namespace string) (*NamespaceState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetState", ctx, namespace)
	ret0, _ := ret[0].(*NamespaceState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetState indicates an expected call of GetState.
func (mr *MockStoreMockRecorder) GetState(ctx, namespace any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetState", reflect.TypeOf((*MockStore)(nil).GetState), ctx, namespace)
}

// RecordHeartbeat mocks base method.
func (m *MockStore) RecordHeartbeat(ctx context.Context, namespace, executorID string, state HeartbeatState) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RecordHeartbeat", ctx, namespace, executorID, state)
	ret0, _ := ret[0].(error)
	return ret0
}

// RecordHeartbeat indicates an expected call of RecordHeartbeat.
func (mr *MockStoreMockRecorder) RecordHeartbeat(ctx, namespace, executorID, state any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RecordHeartbeat", reflect.TypeOf((*MockStore)(nil).RecordHeartbeat), ctx, namespace, executorID, state)
}

// Subscribe mocks base method.
func (m *MockStore) Subscribe(ctx context.Context, namespace string) (<-chan NameSpaceEvent, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subscribe", ctx, namespace)
	ret0, _ := ret[0].(<-chan NameSpaceEvent)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockStoreMockRecorder) Subscribe(ctx, namespace any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockStore)(nil).Subscribe), ctx, namespace)
}
