package metered

// Code generated by gowrap. DO NOT EDIT.
// template: ../templates/metered.tmpl
// gowrap: http://github.com/hexdigest/gowrap

import (
	"context"

	"github.com/uber/cadence/common/clock"
	"github.com/uber/cadence/common/log"
	"github.com/uber/cadence/common/metrics"
	"github.com/uber/cadence/service/sharddistributor/store"
)

// meteredStore implements store.Store interface instrumented with metrics.
type meteredStore struct {
	base
	wrapped store.Store
}

// NewStore creates a new instance of Store with metrics.
func NewStore(
	wrapped store.Store,
	metricClient metrics.Client,
	logger log.Logger,
	timeSource clock.TimeSource,
) store.Store {
	if wrapped == nil {
		return nil
	}
	return &meteredStore{
		wrapped: wrapped,
		base: base{
			metricClient: metricClient,
			logger:       logger,
			timeSource:   timeSource,
		},
	}
}

func (c *meteredStore) AssignShard(ctx context.Context, namespace string, shardID string, executorID string) (err error) {
	op := func() error {
		err = c.wrapped.AssignShard(ctx, namespace, shardID, executorID)
		return err
	}

	err = c.call(metrics.ShardDistributorStoreAssignShardScope, op, metrics.NamespaceTag(namespace))
	return
}

func (c *meteredStore) AssignShards(ctx context.Context, namespace string, request store.AssignShardsRequest, guard store.GuardFunc) (err error) {
	op := func() error {
		err = c.wrapped.AssignShards(ctx, namespace, request, guard)
		return err
	}

	err = c.call(metrics.ShardDistributorStoreAssignShardsScope, op, metrics.NamespaceTag(namespace))
	return
}

func (c *meteredStore) DeleteExecutors(ctx context.Context, namespace string, executorIDs []string, guard store.GuardFunc) (err error) {
	op := func() error {
		err = c.wrapped.DeleteExecutors(ctx, namespace, executorIDs, guard)
		return err
	}

	err = c.call(metrics.ShardDistributorStoreDeleteExecutorsScope, op, metrics.NamespaceTag(namespace))
	return
}

func (c *meteredStore) GetHeartbeat(ctx context.Context, namespace string, executorID string) (hp1 *store.HeartbeatState, ap1 *store.AssignedState, err error) {
	op := func() error {
		hp1, ap1, err = c.wrapped.GetHeartbeat(ctx, namespace, executorID)
		return err
	}

	err = c.call(metrics.ShardDistributorStoreGetHeartbeatScope, op, metrics.NamespaceTag(namespace))
	return
}

func (c *meteredStore) GetShardOwner(ctx context.Context, namespace string, shardID string) (s1 string, err error) {
	op := func() error {
		s1, err = c.wrapped.GetShardOwner(ctx, namespace, shardID)
		return err
	}

	err = c.call(metrics.ShardDistributorStoreGetShardOwnerScope, op, metrics.NamespaceTag(namespace))
	return
}

func (c *meteredStore) GetState(ctx context.Context, namespace string) (np1 *store.NamespaceState, err error) {
	op := func() error {
		np1, err = c.wrapped.GetState(ctx, namespace)
		return err
	}

	err = c.call(metrics.ShardDistributorStoreGetStateScope, op, metrics.NamespaceTag(namespace))
	return
}

func (c *meteredStore) RecordHeartbeat(ctx context.Context, namespace string, executorID string, state store.HeartbeatState) (err error) {
	op := func() error {
		err = c.wrapped.RecordHeartbeat(ctx, namespace, executorID, state)
		return err
	}

	err = c.call(metrics.ShardDistributorStoreRecordHeartbeatScope, op, metrics.NamespaceTag(namespace))
	return
}

func (c *meteredStore) Subscribe(ctx context.Context, namespace string) (ch1 <-chan store.NameSpaceEvent, err error) {
	op := func() error {
		ch1, err = c.wrapped.Subscribe(ctx, namespace)
		return err
	}

	err = c.call(metrics.ShardDistributorStoreSubscribeScope, op, metrics.NamespaceTag(namespace))
	return
}
