// Code generated by gowrap. DO NOT EDIT.
// template: ../../templates/metered.tmpl
// gowrap: http://github.com/hexdigest/gowrap

package metered

//go:generate gowrap gen -p github.com/uber/cadence/service/history/handler -i Handler -t ../../templates/metered.tmpl -o handler_generated.go -v handler=History -l ""

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/uber/cadence/common"
	"github.com/uber/cadence/common/cache"
	"github.com/uber/cadence/common/log"
	"github.com/uber/cadence/common/membership"
	"github.com/uber/cadence/common/metrics"
	"github.com/uber/cadence/common/types"
	"github.com/uber/cadence/service/history/config"
	"github.com/uber/cadence/service/history/constants"
	"github.com/uber/cadence/service/history/handler"
)

// historyHandler frontend handler wrapper for authentication and authorization
type historyHandler struct {
	handler            handler.Handler
	logger             log.Logger
	metricsClient      metrics.Client
	domainCache        cache.DomainCache
	tokenSerializer    common.TaskTokenSerializer
	startWG            sync.WaitGroup
	hostInfo           membership.HostInfo
	memberShipResolver membership.Resolver
}

// NewHistoryHandler creates frontend handler with metrics and logging
func NewHistoryHandler(handler handler.Handler, logger log.Logger, metricsClient metrics.Client, domainCache cache.DomainCache, cfg *config.Config) handler.Handler {
	return &historyHandler{
		handler:         handler,
		logger:          logger,
		metricsClient:   metricsClient,
		domainCache:     domainCache,
		tokenSerializer: common.NewJSONTaskTokenSerializer(),
	}
}

func (h *historyHandler) CloseShard(ctx context.Context, cp1 *types.CloseShardRequest) (err error) {
	return h.handler.CloseShard(ctx, cp1)
}

func (h *historyHandler) CountDLQMessages(ctx context.Context, cp1 *types.CountDLQMessagesRequest) (hp1 *types.HistoryCountDLQMessagesResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryCountDLQMessagesScope)
	defer sw.Stop()
	domainID := ""
	// We don't have the workflowID and runID, so just pass empty strings
	workflowID := ""
	runID := ""

	hp1, err = h.handler.CountDLQMessages(ctx, cp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return hp1, err
}

func (h *historyHandler) DescribeHistoryHost(ctx context.Context, dp1 *types.DescribeHistoryHostRequest) (dp2 *types.DescribeHistoryHostResponse, err error) {
	return h.handler.DescribeHistoryHost(ctx, dp1)
}

func (h *historyHandler) DescribeMutableState(ctx context.Context, dp1 *types.DescribeMutableStateRequest) (dp2 *types.DescribeMutableStateResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryDescribeMutableStateScope)
	defer sw.Stop()
	domainID := dp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := dp1.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	dp2, err = h.handler.DescribeMutableState(ctx, dp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return dp2, err
}

func (h *historyHandler) DescribeQueue(ctx context.Context, dp1 *types.DescribeQueueRequest) (dp2 *types.DescribeQueueResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryDescribeQueueScope)
	defer sw.Stop()
	domainID := ""
	// We don't have the workflowID and runID, so just pass empty strings
	workflowID := ""
	runID := ""

	dp2, err = h.handler.DescribeQueue(ctx, dp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return dp2, err
}

func (h *historyHandler) DescribeWorkflowExecution(ctx context.Context, hp1 *types.HistoryDescribeWorkflowExecutionRequest) (dp1 *types.DescribeWorkflowExecutionResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryDescribeWorkflowExecutionScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := hp1.Request.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	dp1, err = h.handler.DescribeWorkflowExecution(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return dp1, err
}

func (h *historyHandler) GetCrossClusterTasks(ctx context.Context, gp1 *types.GetCrossClusterTasksRequest) (gp2 *types.GetCrossClusterTasksResponse, err error) {
	return h.handler.GetCrossClusterTasks(ctx, gp1)
}

func (h *historyHandler) GetDLQReplicationMessages(ctx context.Context, gp1 *types.GetDLQReplicationMessagesRequest) (gp2 *types.GetDLQReplicationMessagesResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryGetDLQReplicationMessagesScope)
	defer sw.Stop()
	domainID := ""
	// We don't have the workflowID and runID, so just pass empty strings
	workflowID := ""
	runID := ""

	gp2, err = h.handler.GetDLQReplicationMessages(ctx, gp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return gp2, err
}

func (h *historyHandler) GetFailoverInfo(ctx context.Context, gp1 *types.GetFailoverInfoRequest) (gp2 *types.GetFailoverInfoResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryGetFailoverInfoScope)
	defer sw.Stop()
	domainID := ""
	// We don't have the workflowID and runID, so just pass empty strings
	workflowID := ""
	runID := ""

	gp2, err = h.handler.GetFailoverInfo(ctx, gp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return gp2, err
}

func (h *historyHandler) GetMutableState(ctx context.Context, gp1 *types.GetMutableStateRequest) (gp2 *types.GetMutableStateResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryGetMutableStateScope)
	defer sw.Stop()
	domainID := gp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := gp1.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	gp2, err = h.handler.GetMutableState(ctx, gp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return gp2, err
}

func (h *historyHandler) GetReplicationMessages(ctx context.Context, gp1 *types.GetReplicationMessagesRequest) (gp2 *types.GetReplicationMessagesResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryGetReplicationMessagesScope)
	defer sw.Stop()
	domainID := ""
	// We don't have the workflowID and runID, so just pass empty strings
	workflowID := ""
	runID := ""

	gp2, err = h.handler.GetReplicationMessages(ctx, gp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return gp2, err
}

func (h *historyHandler) Health(ctx context.Context) (hp1 *types.HealthStatus, err error) {
	return h.handler.Health(ctx)
}

func (h *historyHandler) MergeDLQMessages(ctx context.Context, mp1 *types.MergeDLQMessagesRequest) (mp2 *types.MergeDLQMessagesResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryMergeDLQMessagesScope)
	defer sw.Stop()
	domainID := ""
	// We don't have the workflowID and runID, so just pass empty strings
	workflowID := ""
	runID := ""

	mp2, err = h.handler.MergeDLQMessages(ctx, mp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return mp2, err
}

func (h *historyHandler) NotifyFailoverMarkers(ctx context.Context, np1 *types.NotifyFailoverMarkersRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryNotifyFailoverMarkersScope)
	defer sw.Stop()
	domainID := ""
	// We don't have the workflowID and runID, so just pass empty strings
	workflowID := ""
	runID := ""

	err = h.handler.NotifyFailoverMarkers(ctx, np1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) PollMutableState(ctx context.Context, pp1 *types.PollMutableStateRequest) (pp2 *types.PollMutableStateResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryPollMutableStateScope)
	defer sw.Stop()
	domainID := pp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := pp1.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	pp2, err = h.handler.PollMutableState(ctx, pp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return pp2, err
}

func (h *historyHandler) PrepareToStop(d1 time.Duration) (d2 time.Duration) {
	return h.handler.PrepareToStop(d1)
}

func (h *historyHandler) PurgeDLQMessages(ctx context.Context, pp1 *types.PurgeDLQMessagesRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryPurgeDLQMessagesScope)
	defer sw.Stop()
	domainID := ""
	// We don't have the workflowID and runID, so just pass empty strings
	workflowID := ""
	runID := ""

	err = h.handler.PurgeDLQMessages(ctx, pp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) QueryWorkflow(ctx context.Context, hp1 *types.HistoryQueryWorkflowRequest) (hp2 *types.HistoryQueryWorkflowResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryQueryWorkflowScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := hp1.Request.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	hp2, err = h.handler.QueryWorkflow(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return hp2, err
}

func (h *historyHandler) RatelimitUpdate(ctx context.Context, rp1 *types.RatelimitUpdateRequest) (rp2 *types.RatelimitUpdateResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryRatelimitUpdateScope)
	defer sw.Stop()
	domainID := ""
	// We don't have the workflowID and runID, so just pass empty strings
	workflowID := ""
	runID := ""

	rp2, err = h.handler.RatelimitUpdate(ctx, rp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return rp2, err
}

func (h *historyHandler) ReadDLQMessages(ctx context.Context, rp1 *types.ReadDLQMessagesRequest) (rp2 *types.ReadDLQMessagesResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryReadDLQMessagesScope)
	defer sw.Stop()
	domainID := ""
	// We don't have the workflowID and runID, so just pass empty strings
	workflowID := ""
	runID := ""

	rp2, err = h.handler.ReadDLQMessages(ctx, rp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return rp2, err
}

func (h *historyHandler) ReapplyEvents(ctx context.Context, hp1 *types.HistoryReapplyEventsRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryReapplyEventsScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := hp1.Request.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	err = h.handler.ReapplyEvents(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) RecordActivityTaskHeartbeat(ctx context.Context, hp1 *types.HistoryRecordActivityTaskHeartbeatRequest) (rp1 *types.RecordActivityTaskHeartbeatResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryRecordActivityTaskHeartbeatScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the task token
	serializedToken := hp1.Request.TaskToken
	token, err := h.tokenSerializer.Deserialize(serializedToken)
	if err != nil {
		err = &types.BadRequestError{Message: fmt.Sprintf("Error deserializing task token. Error: %v", err)}
		err = h.error(err, scope, domainID, "", "")
		return
	}

	err = validateTaskToken(token)
	if err != nil {
		err = h.error(err, scope, domainID, "", "")
		return
	}

	workflowID := token.WorkflowID
	runID := token.RunID

	rp1, err = h.handler.RecordActivityTaskHeartbeat(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return rp1, err
}

func (h *historyHandler) RecordActivityTaskStarted(ctx context.Context, rp1 *types.RecordActivityTaskStartedRequest) (rp2 *types.RecordActivityTaskStartedResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryRecordActivityTaskStartedScope)
	defer sw.Stop()
	domainID := rp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := rp1.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	rp2, err = h.handler.RecordActivityTaskStarted(ctx, rp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return rp2, err
}

func (h *historyHandler) RecordChildExecutionCompleted(ctx context.Context, rp1 *types.RecordChildExecutionCompletedRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryRecordChildExecutionCompletedScope)
	defer sw.Stop()
	domainID := rp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := rp1.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	err = h.handler.RecordChildExecutionCompleted(ctx, rp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) RecordDecisionTaskStarted(ctx context.Context, rp1 *types.RecordDecisionTaskStartedRequest) (rp2 *types.RecordDecisionTaskStartedResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryRecordDecisionTaskStartedScope)
	defer sw.Stop()
	domainID := rp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := rp1.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	rp2, err = h.handler.RecordDecisionTaskStarted(ctx, rp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return rp2, err
}

func (h *historyHandler) RefreshWorkflowTasks(ctx context.Context, hp1 *types.HistoryRefreshWorkflowTasksRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryRefreshWorkflowTasksScope)
	defer sw.Stop()
	domainID := ""
	// Get the workflowID and runID from the workflow execution
	workflowExecution := hp1.Request.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	err = h.handler.RefreshWorkflowTasks(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) RemoveSignalMutableState(ctx context.Context, rp1 *types.RemoveSignalMutableStateRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryRemoveSignalMutableStateScope)
	defer sw.Stop()
	domainID := rp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := rp1.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	err = h.handler.RemoveSignalMutableState(ctx, rp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) RemoveTask(ctx context.Context, rp1 *types.RemoveTaskRequest) (err error) {
	return h.handler.RemoveTask(ctx, rp1)
}

func (h *historyHandler) ReplicateEventsV2(ctx context.Context, rp1 *types.ReplicateEventsV2Request) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryReplicateEventsV2Scope)
	defer sw.Stop()
	domainID := rp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := rp1.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	err = h.handler.ReplicateEventsV2(ctx, rp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) RequestCancelWorkflowExecution(ctx context.Context, hp1 *types.HistoryRequestCancelWorkflowExecutionRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryRequestCancelWorkflowExecutionScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := hp1.Request.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	err = h.handler.RequestCancelWorkflowExecution(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) ResetQueue(ctx context.Context, rp1 *types.ResetQueueRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryResetQueueScope)
	defer sw.Stop()
	domainID := ""
	// We don't have the workflowID and runID, so just pass empty strings
	workflowID := ""
	runID := ""

	err = h.handler.ResetQueue(ctx, rp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) ResetStickyTaskList(ctx context.Context, hp1 *types.HistoryResetStickyTaskListRequest) (hp2 *types.HistoryResetStickyTaskListResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryResetStickyTaskListScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := hp1.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	hp2, err = h.handler.ResetStickyTaskList(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return hp2, err
}

func (h *historyHandler) ResetWorkflowExecution(ctx context.Context, hp1 *types.HistoryResetWorkflowExecutionRequest) (rp1 *types.ResetWorkflowExecutionResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryResetWorkflowExecutionScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := hp1.Request.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	rp1, err = h.handler.ResetWorkflowExecution(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return rp1, err
}

func (h *historyHandler) RespondActivityTaskCanceled(ctx context.Context, hp1 *types.HistoryRespondActivityTaskCanceledRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryRespondActivityTaskCanceledScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the task token
	serializedToken := hp1.Request.TaskToken
	token, err := h.tokenSerializer.Deserialize(serializedToken)
	if err != nil {
		err = &types.BadRequestError{Message: fmt.Sprintf("Error deserializing task token. Error: %v", err)}
		err = h.error(err, scope, domainID, "", "")
		return
	}

	err = validateTaskToken(token)
	if err != nil {
		err = h.error(err, scope, domainID, "", "")
		return
	}

	workflowID := token.WorkflowID
	runID := token.RunID

	err = h.handler.RespondActivityTaskCanceled(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) RespondActivityTaskCompleted(ctx context.Context, hp1 *types.HistoryRespondActivityTaskCompletedRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryRespondActivityTaskCompletedScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the task token
	serializedToken := hp1.Request.TaskToken
	token, err := h.tokenSerializer.Deserialize(serializedToken)
	if err != nil {
		err = &types.BadRequestError{Message: fmt.Sprintf("Error deserializing task token. Error: %v", err)}
		err = h.error(err, scope, domainID, "", "")
		return
	}

	err = validateTaskToken(token)
	if err != nil {
		err = h.error(err, scope, domainID, "", "")
		return
	}

	workflowID := token.WorkflowID
	runID := token.RunID

	err = h.handler.RespondActivityTaskCompleted(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) RespondActivityTaskFailed(ctx context.Context, hp1 *types.HistoryRespondActivityTaskFailedRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryRespondActivityTaskFailedScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the task token
	serializedToken := hp1.Request.TaskToken
	token, err := h.tokenSerializer.Deserialize(serializedToken)
	if err != nil {
		err = &types.BadRequestError{Message: fmt.Sprintf("Error deserializing task token. Error: %v", err)}
		err = h.error(err, scope, domainID, "", "")
		return
	}

	err = validateTaskToken(token)
	if err != nil {
		err = h.error(err, scope, domainID, "", "")
		return
	}

	workflowID := token.WorkflowID
	runID := token.RunID

	err = h.handler.RespondActivityTaskFailed(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) RespondCrossClusterTasksCompleted(ctx context.Context, rp1 *types.RespondCrossClusterTasksCompletedRequest) (rp2 *types.RespondCrossClusterTasksCompletedResponse, err error) {
	return h.handler.RespondCrossClusterTasksCompleted(ctx, rp1)
}

func (h *historyHandler) RespondDecisionTaskCompleted(ctx context.Context, hp1 *types.HistoryRespondDecisionTaskCompletedRequest) (hp2 *types.HistoryRespondDecisionTaskCompletedResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryRespondDecisionTaskCompletedScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the task token
	serializedToken := hp1.Request.TaskToken
	token, err := h.tokenSerializer.Deserialize(serializedToken)
	if err != nil {
		err = &types.BadRequestError{Message: fmt.Sprintf("Error deserializing task token. Error: %v", err)}
		err = h.error(err, scope, domainID, "", "")
		return
	}

	err = validateTaskToken(token)
	if err != nil {
		err = h.error(err, scope, domainID, "", "")
		return
	}

	workflowID := token.WorkflowID
	runID := token.RunID

	hp2, err = h.handler.RespondDecisionTaskCompleted(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return hp2, err
}

func (h *historyHandler) RespondDecisionTaskFailed(ctx context.Context, hp1 *types.HistoryRespondDecisionTaskFailedRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryRespondDecisionTaskFailedScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the task token
	serializedToken := hp1.Request.TaskToken
	token, err := h.tokenSerializer.Deserialize(serializedToken)
	if err != nil {
		err = &types.BadRequestError{Message: fmt.Sprintf("Error deserializing task token. Error: %v", err)}
		err = h.error(err, scope, domainID, "", "")
		return
	}

	err = validateTaskToken(token)
	if err != nil {
		err = h.error(err, scope, domainID, "", "")
		return
	}

	workflowID := token.WorkflowID
	runID := token.RunID

	err = h.handler.RespondDecisionTaskFailed(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) ScheduleDecisionTask(ctx context.Context, sp1 *types.ScheduleDecisionTaskRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryScheduleDecisionTaskScope)
	defer sw.Stop()
	domainID := sp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := sp1.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	err = h.handler.ScheduleDecisionTask(ctx, sp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) SignalWithStartWorkflowExecution(ctx context.Context, hp1 *types.HistorySignalWithStartWorkflowExecutionRequest) (sp1 *types.StartWorkflowExecutionResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistorySignalWithStartWorkflowExecutionScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	//start

	sp1, err = h.handler.SignalWithStartWorkflowExecution(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return sp1, err
}

func (h *historyHandler) SignalWorkflowExecution(ctx context.Context, hp1 *types.HistorySignalWorkflowExecutionRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistorySignalWorkflowExecutionScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := hp1.Request.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	err = h.handler.SignalWorkflowExecution(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) Start() {
	h.handler.Start()
	return
}

func (h *historyHandler) StartWorkflowExecution(ctx context.Context, hp1 *types.HistoryStartWorkflowExecutionRequest) (sp1 *types.StartWorkflowExecutionResponse, err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryStartWorkflowExecutionScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	//start

	sp1, err = h.handler.StartWorkflowExecution(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return sp1, err
}

func (h *historyHandler) Stop() {
	h.handler.Stop()
	return
}

func (h *historyHandler) SyncActivity(ctx context.Context, sp1 *types.SyncActivityRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistorySyncActivityScope)
	defer sw.Stop()
	domainID := ""
	// request

	err = h.handler.SyncActivity(ctx, sp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) SyncShardStatus(ctx context.Context, sp1 *types.SyncShardStatusRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistorySyncShardStatusScope)
	defer sw.Stop()
	domainID := ""
	// We don't have the workflowID and runID, so just pass empty strings
	workflowID := ""
	runID := ""

	err = h.handler.SyncShardStatus(ctx, sp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}

func (h *historyHandler) TerminateWorkflowExecution(ctx context.Context, hp1 *types.HistoryTerminateWorkflowExecutionRequest) (err error) {
	defer func() { log.CapturePanic(recover(), h.logger, &err) }()
	h.startWG.Wait()

	scope, sw := h.startRequestProfile(ctx, metrics.HistoryTerminateWorkflowExecutionScope)
	defer sw.Stop()
	domainID := hp1.GetDomainUUID()
	if domainID == "" {
		err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
		return
	}
	// Get the workflowID and runID from the workflow execution
	workflowExecution := hp1.Request.WorkflowExecution
	workflowID := workflowExecution.GetWorkflowID()
	runID := workflowExecution.GetRunID()

	err = h.handler.TerminateWorkflowExecution(ctx, hp1)
	if err != nil {
		err = h.error(err, scope, domainID, workflowID, runID)
		return
	}
	return err
}
