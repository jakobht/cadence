import (
"context"

"github.com/uber/cadence/common/log"
"github.com/uber/cadence/common/log/tag"
"github.com/uber/cadence/common/metrics"
"github.com/uber/cadence/common/types"
"github.com/uber/cadence/service/frontend/api"
)

{{- $nonMeteredAPIs := list "Start" "Stop" "PrepareToStop" "Health" "DescribeHistoryHost" "RemoveTask" "CloseShard"
    "GetCrossClusterTasks" "RespondCrossClusterTasksCompleted"}}
{{- $nonDomainSpecificAPIs := list "CountDLQMessages" "DescribeQueue" "GetDLQReplicationMessages" "GetFailoverInfo"
    "GetReplicationMessages" "MergeDLQMessages" "NotifyFailoverMarkers" "PurgeDLQMessages" "RatelimitUpdate"
    "ReadDLQMessages" "RefreshWorkflowTasks" "ResetQueue" "SyncActivity" "SyncShardStatus"}}

{{- $workflowInfoRetrieval := dict
    "RecordActivityTaskHeartbeat" "token"
    "RecordActivityTaskStarted" "workflowExecution"
    "RecordDecisionTaskStarted" "workflowExecution"
    "RespondActivityTaskCompleted" "token"
    "RespondActivityTaskFailed" "token"
    "RespondActivityTaskCanceled" "token"
    "RespondDecisionTaskCompleted" "token"
    "RespondDecisionTaskFailed" "token"
    "StartWorkflowExecution" "start"
    "ResetQueue" "none"
    "DescribeQueue" "none"
    "DescribeMutableState" "workflowExecution"
    "GetMutableState" "workflowExecution"
    "PollMutableState" "workflowExecution"
    "DescribeWorkflowExecution" "workflowExecutionViaRequest"
    "RequestCancelWorkflowExecution" "workflowExecutionViaRequest"
    "SignalWorkflowExecution" "workflowExecutionViaRequest"
    "SignalWithStartWorkflowExecution" "start"
    "RemoveSignalMutableState" "workflowExecution"
    "TerminateWorkflowExecution" "workflowExecutionViaRequest"
    "ResetWorkflowExecution" "workflowExecutionViaRequest"
    "QueryWorkflow" "workflowExecutionViaRequest"
    "ScheduleDecisionTask" "workflowExecution"
    "RecordChildExecutionCompleted" "workflowExecution"
    "ResetStickyTaskList" "workflowExecution"
    "ReplicateEventsV2" "workflowExecution"
    "SyncShardStatus" "none"
    "SyncActivity" "request"
    "GetReplicationMessages" "none"
    "GetDLQReplicationMessages" "none"
    "ReapplyEvents" "workflowExecutionViaRequest"
    "CountDLQMessages" "none"
    "ReadDLQMessages" "none"
    "PurgeDLQMessages" "none"
    "MergeDLQMessages" "none"
    "RefreshWorkflowTasks" "workflowExecutionViaRequest"
    "NotifyFailoverMarkers" "none"
    "GetFailoverInfo" "none"
    "RatelimitUpdate" "none"
}}


{{- $interfaceName := .Interface.Name}}
{{- $interfaceType := .Interface.Type}}
{{- $handlerName := (index .Vars "handler")}}
{{- $decorator := (printf "%s%s" (down $handlerName) $interfaceName) }}
{{- $Decorator := (printf "%s%s" $handlerName $interfaceName) }}

// {{$decorator}} frontend handler wrapper for authentication and authorization
type {{$decorator}} struct {
handler {{.Interface.Type}}
logger log.Logger
metricsClient metrics.Client
domainCache cache.DomainCache
tokenSerializer common.TaskTokenSerializer
startWG sync.WaitGroup
hostInfo membership.HostInfo
memberShipResolver membership.Resolver

}

// New{{$Decorator}} creates frontend handler with metrics and logging
func New{{$Decorator}}(handler {{$.Interface.Type}}, logger log.Logger, metricsClient metrics.Client, domainCache cache.DomainCache, cfg *config.Config) {{.Interface.Type}} {
return &{{$decorator}}{
handler: handler,
logger: logger,
metricsClient: metricsClient,
domainCache: domainCache,
tokenSerializer: common.NewJSONTaskTokenSerializer(),
}
}

{{range $method := .Interface.Methods}}
    func (h *{{$decorator}}) {{$method.Declaration}} {
    {{- if has $method.Name $nonMeteredAPIs}}
        {{ $method.Pass "h.handler." }}
    {{- else}}
        defer func() { log.CapturePanic(recover(), h.logger, &err) }()
        h.startWG.Wait()

        {{- $scope := printf "metrics.History%sScope" $method.Name}}
        {{ $req := (index $method.Params 1).Name }}

        scope, sw := h.startRequestProfile(ctx, {{$scope}})
        defer sw.Stop()

        {{- if has $method.Name $nonDomainSpecificAPIs}}
            domainID := ""
        {{- else }}
            domainID := {{- printf "%s.GetDomainUUID()" $req}}
            if domainID == "" {
                err = h.error(constants.ErrDomainNotSet, scope, domainID, "", "")
                return
            }
        {{- end }}

        {{- $wfInfoMode := get $workflowInfoRetrieval $method.Name}}
        {{- if eq $wfInfoMode "token"}}
            // Get the workflowID and runID from the task token
            serializedToken := {{- printf "%s.Request.TaskToken" $req}}
            token, err := h.tokenSerializer.Deserialize(serializedToken)
            if err != nil {
                err = &types.BadRequestError{Message: fmt.Sprintf("Error deserializing task token. Error: %v", err)}
                err = h.error(err, scope, domainID, "", "")
                return
            }

            err = validateTaskToken(token)
            if err != nil {
                err = h.error(err, scope, domainID, "", "")
                return
            }

            workflowID := token.WorkflowID
            runID := token.RunID
        {{- else if eq $wfInfoMode "workflowExecution"}}
            // Get the workflowID and runID from the workflow execution
            workflowExecution := {{- $req -}}.WorkflowExecution
            workflowID := workflowExecution.GetWorkflowID()
            runID := workflowExecution.GetRunID()
        {{- else if eq $wfInfoMode "workflowExecutionViaRequest"}}
            // Get the workflowID and runID from the workflow execution
            workflowExecution := {{- $req -}}.Request.WorkflowExecution
            workflowID := workflowExecution.GetWorkflowID()
            runID := workflowExecution.GetRunID()
        {{- else if eq $wfInfoMode "start"}}
            //start
        {{- else if eq $wfInfoMode "none"}}
            // We don't have the workflowID and runID, so just pass empty strings
            workflowID := ""
            runID := ""
        {{- else if eq $wfInfoMode "request"}}
            // request
        {{- else}}
            // ERROR
        {{- end}}

        {{$method.ResultsNames}} = h.handler.{{$method.Call}}
        if err != nil {
            err = h.error(err, scope, domainID, workflowID, runID)
            return
        }
        return {{$method.ResultsNames}}
    {{- end}}
    }
{{end}}
